#+title: Flake
# -*- org-src-preserve-indentation: t; -*-
#+property: header-args :tangle flake.nix 
tangle command: C-c C-v t


Preamble and Start expression
#+begin_src nix
{
  description = "Taeru's config flake";
#+end_src


* Flake Inputs
Start Inputs block
#+begin_src nix
  inputs = {
#+end_src

** Hardware
Bring in the community hardware repo, that way we don't have to re-invent a ton of obvious hardware stuff
#+begin_src nix
    nixos-hardware.url = "github:NixOS/nixos-hardware/master";
#+end_src

** Nixpkgs
Establish inputs to both unstable and stable packages.
Generally, unstable is fine but if something is misbehaving, we have Stable as a fallback.
#+begin_src nix    
    nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
    nixpkgs-stable.url = "github:nixos/nixpkgs/nixos-25.05";
#+end_src

** Home-Manager
Use the same "unstable & stable" pattern for home-manager.
#+begin_src nix
    home-manager.url = "github:nix-community/home-manager";
    home-manager-stable.url = "github:nix-community/home-manager/release-25.05";
    home-manager.inputs.nixpkgs.follows = "nixpkgs";
#+end_src

** Secrets Management
#+begin_src nix
    sops-nix = {
      url = "github:Mic92/sops-nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    agenix.url = "github:ryantm/agenix";
#+end_src


** Hyprland
For awhile, hyprland was iterating much faster than nixpkgs would keep up with, so we get it directly. 
#+begin_src nix
    hyprland.url = "github:hyprwm/Hyprland";
    hyprland-plugins = {
      url = "github:hyprwm/hyprland-plugins";
      inputs.hyprland.follows = "hyprland";
    };
#+end_src

** Stylix
stylix was used as part of styling Hyprland.
#+begin_src nix
    stylix.url = "github:danth/stylix";
#+end_src

** Nixos-wsl
This is a specific tools for running in a Windows Subsystem for Linux environment.
#+begin_src nix
    # Only needed for Windows Subsystem for Linux
    nixos-wsl.url = "github:nix-community/NixOS-WSL/main";
#+end_src

** Emacs
I keep going back and forth between running doom emacs or trying to make my own Helix Mode emacs flavor.
I haven't fully decided.
#+begin_src nix
    emacs-overlay.url = "github:nix-community/emacs-overlay";
    nix-doom-emacs-unstraightened.url = "github:marienz/nix-doom-emacs-unstraightened";
#+end_src

** Matui - Matrix Client
Matui is a matrix client https://github.com/pkulak/matui
#+begin_src nix
    matui.url = "github:pkulak/matui";
#+end_src

** expression closure
End Inputs block
#+begin_src nix
  };
#+end_src

* Flake Outputs
The business end of the whole flake!

These are the nix expression inputs. I prefer to keep this as "pure" as I can, meaning only pointing at Nixpkgs and Home-Manager.
I could probably shift those to also be explicit Input/Output pointers too.
#+begin_src nix
  outputs = {
    self,
    nixpkgs,
    home-manager,
    ...
    }@inputs:
    let
      inherit (self) outputs;
      # Supported systems for your flake packages, shell, etc.
      systems = [ "x86_64-linux" ];
      # This is a function that generates an attribute by calling a function you
      # pass to it, with each system as an argument
      forAllSystems = nixpkgs.lib.genAttrs systems;
    in
    {
#+end_src

** Preamble
#+begin_src nix
      # Add any packages we have made
      customPkgs = import ./pkgs;

      # Formatter for your nix files, available through 'nix fmt'
      formatter = forAllSystems (system: nixpkgs.legacyPackages.${system}.treefmt);

      # Your custom packages and modifications, exported as overlays
      overlays = import ./overlays { inherit inputs; };
      nixosModules = import ./modules/nixos;
      homeManagerModules = import ./modules/home-manager;

      hostConfigs = import ./hosts;
      userConfigs = import ./users;
#+end_src

** Nix Systems
#+begin_src nix
      # NixOS configuration entrypoint
      # Available through 'nixos-rebuild --flake .#your-hostname'
      nixosConfigurations = {
#+end_src

*** Ares
A Nixos install on a Surface Pro 2017
#+begin_src nix
        ares = nixpkgs.lib.nixosSystem {
          specialArgs = { inherit inputs outputs; };
          modules = [ outputs.hostConfigs.ares ];
        };
#+end_src

*** Artemis
A Nixos-WSL on a Zenbook Duo 2024, generally used for school
#+begin_src nix
        artemis = nixpkgs.lib.nixosSystem {
          specialArgs = { inherit inputs outputs; };
          Modules = [ outputs.hostConfigs.artemis ];
        };
#+end_src
*** Zeus
The main desktop install
#+begin_src nix
        zeus = nixpkgs.lib.nixosSystem {
          specialArgs = { inherit inputs outputs; };
          modules = [ outputs.hostConfigs.zeus ];
        };
#+end_src

*** Nix Systems Closure
#+begin_src nix
      };
#+end_src

** Home-Manager Configurations
#+begin_src nix
      # Standalone home-manager configuration entrypoint
      # Available through 'home-manager --flake .#your-username@your-hostname'
      homeConfigurations = {
#+end_src
*** Astraeaf
**** Artemis
Artemis is uses the Core definition because its important to keep it thin and light. Its mostly a Windows system due to the hardware.
#+begin_src nix
        "astraeaf@artemis" = home-manager.lib.homeManagerConfiguration {
          pkgs = nixpkgs.legacyPackages.x86_64-linux;
          extraSpecialArgs = { inherit inputs outputs; };
          modules = [ outputs.userConfigs.astraeaf.core ];
        };
#+end_src

**** Zeus
This ones gets the Heavy config, which includes the Core stuff too.
#+begin_src nix
        "astraeaf@zeus" = home-manager.lib.homeManagerConfiguration {
          pkgs = nixpkgs.legacyPackages.x86_64-linux;
          extraSpecialArgs = { inherit inputs outputs; };
          modules = [ outputs.userConfigs.astraeaf.heavy ];
        };
#+end_src
*** Home-Manager Closure
#+begin_src nix
      };
#+end_src
** Output Closure
#+begin_src nix
    };
#+end_src

* Flake Expression Closure
#+begin_src nix
}
#+end_src
